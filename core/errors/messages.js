"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnknownDependenciesMessage = (type) => `Coven could not resolve dependency of ${type}, if component make sure you include its class in the 'components' metatdata property of @CLIProgram.`;
exports.UNHANDLED_RUNTIME_EXCEPTION = `An unhandled Coven runtime exception occured.`;
exports.INVALID_EXCEPTION_TRAP = `Invalid Exception Traps (@UseTraps()).`;
exports.UNKNOWN_MAPPING = (name, decorator, type) => `${name} mapping property not defined in ${decorator}() annotation for class - ${type}!`;
exports.IMPROPER_MAPPING = (name, decorator, type) => `${name} mapping property not properly defined in ${decorator}() annotation for class - ${type}!`;
exports.MISSING_REQUIRED_OPTION = (option) => `error: option ${option} argument is missing`;
exports.SHORT_FLAG_OPTION_MAPPING = (option_typename) => `shortFlag mapping property for ${option_typename} class's @CLIOption doesn't contain the single character flag required`;
exports.SHORT_FLAG_VALID_ASCII_MAPPING = (option_typename) => `shortFlag mapping property for ${option_typename} class's @CLIOption doesn't contain a valid ascii alphabet character`;
exports.VALID_STRING_MAPPING = (option_property, option_typename, target) => `${option_property} mapping property for ${option_typename} class's ${target} is not a string`;
exports.VALID_REGEXP_MAPPING = (option_property, option_typename, target) => `${option_property} mapping property for ${option_typename} class's ${target} is not a regular expression object`;
exports.FULL_FLAG_VALID_ASCII_DASH_MAPPING = (option_typename) => `fullFlag mapping property for ${option_typename} class's @CLIOption doesn't contain the valid ascii alphabet characters and dash allowed`;
exports.FLAG_REQUIREMENT_PROVISO = (option_typename) => `An option that has a 'isFlagArgRequired' property that evaluates as true, cannot be marked with optional markers.This is for ${option_typename} class's @CLIOption`;
exports.FLAG_OPTIONAL_PROVISO = (option_typename) => `An option that has a 'isFlagArgRequired' property that evaluates as false, cannot be marked with required markers.This is for ${option_typename} class's @CLIOption`;
exports.REGEXP_COERCION_PRESENT = (option_typename) => `An option cannot have both a coercion function and regular expression set on it at the same time. This is for ${option_typename} class's @CLIOption`;
exports.REGEX_OPTION_INVALID = (option, hint) => `invalid option ${option} argument, hint:{${hint}}`;
exports.PROGRAM_ARG_METADATA_INVALID = (program_type) => `Invalid argument property on @CLIProgram for ${program_type}. Should be reference to your @CLIArgument annotated class`;
exports.INVALID_STRING_ARG = (arg_type, arg_typename, arg_meta_type) => `Invalid ${arg_type} argument for ${arg_meta_type} class ${arg_typename}, string value expected`;
exports.INVALID_ARRAY_ARG = (arg_type, arg_typename, arg_meta_type) => `Invalid ${arg_type} argument for ${arg_meta_type} class ${arg_typename}, array value expected`;
exports.INVALID_CLASS_ARG = (arg_type, arg_typename, arg_meta_type, class_type) => `Invalid ${arg_type} argument for ${arg_meta_type} class ${arg_typename}, ${class_type} class references expected`;
exports.PROGRAM_ARG_NO_REQUIRED = (arg_type, arg_meta_type) => `${arg_meta_type} class ${arg_type} must have at least one required argument`;
exports.PROGRAM_ARG_NO_EXECUTE = (arg_type, arg_meta_type) => `${arg_meta_type} class ${arg_type} must have an execute method to run`;
exports.NOT_ALL_REQUIRED_ARGS_PASSED = (arg_type, arg_meta_type) => `Not all the required arguments were passed into ${arg_meta_type} class ${arg_type}'s execute method to run`;
exports.NO_VARIADIC_AND_OPTIONAL_ARG = (arg_type, arg_meta_type) => `You can only include either optional arguments or a variadic argument for ${arg_meta_type} class ${arg_type}'s execute method to run`;
exports.REQ_VARIADIC_AND_OPTIONAL_ARG = (arg_type, arg_meta_type) => `You can only include either optional arguments or a last variadic argument alongside required arguments for ${arg_meta_type} class ${arg_type}'s execute method to run`;
exports.INVALID_ARG_CHARACTERS = (arg, arg_type, arg_meta_type) => `The ${arg_type} argument '${arg}' set on ${arg_meta_type} does not contain just alphabet characters`;
exports.IMPROPER_PROGRAM = (primary, secondary, program_name) => `The @CLIProgram ${program_name} cannot be run as both '${primary}' and '${secondary}' based program types. Re-purpose ${program_name} as one or the other`;
exports.INVALID_COMMAND_ARG = (arg_type, arg_typename, arg_meta_type) => `Cannot use ${arg_type} alongside verbDescription's sub-command feature for ${arg_meta_type} class ${arg_typename}`;
exports.INVALID_ASCII_MAPPING = (property, typename, arg_meta_type) => `${property} property of ${typename} class's ${arg_meta_type} doesn't contain a valid ascii alphabet character`;
exports.INVALID_VERB_ASCII_MAPPING = (property, typename, arg_meta_type) => `${property} property of ${typename} class's ${arg_meta_type} doesn't contain a valid ascii alphabet or special characters('@' or ':' or '*' or '-')`;
exports.INVALID_COMMAND = (cmd) => `${cmd}: command does not exist, try --help`;
exports.REGEXP_NEEDS_FLAGARG = (type, regexpfield, flagfield) => `To use '${regexpfield}' you must also set '${flagfield}' on option class ${type}`;
exports.INVALID_BOOLEAN_MAPPING = (property, typename, arg_meta_type) => `${property} property of ${typename} class's ${arg_meta_type} is not a boolean`;